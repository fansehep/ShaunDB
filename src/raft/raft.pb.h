// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raft.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_raft_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_raft_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_raft_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_raft_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_raft_2eproto;
namespace RaftMes {
class AppendEntriesArgs;
struct AppendEntriesArgsDefaultTypeInternal;
extern AppendEntriesArgsDefaultTypeInternal _AppendEntriesArgs_default_instance_;
class AppendEntriesReply;
struct AppendEntriesReplyDefaultTypeInternal;
extern AppendEntriesReplyDefaultTypeInternal _AppendEntriesReply_default_instance_;
class ApplyMessage;
struct ApplyMessageDefaultTypeInternal;
extern ApplyMessageDefaultTypeInternal _ApplyMessage_default_instance_;
class InstallSnapshotArgs;
struct InstallSnapshotArgsDefaultTypeInternal;
extern InstallSnapshotArgsDefaultTypeInternal _InstallSnapshotArgs_default_instance_;
class InstallSnapshotReply;
struct InstallSnapshotReplyDefaultTypeInternal;
extern InstallSnapshotReplyDefaultTypeInternal _InstallSnapshotReply_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class RaftNode;
struct RaftNodeDefaultTypeInternal;
extern RaftNodeDefaultTypeInternal _RaftNode_default_instance_;
class RequestVoteArgs;
struct RequestVoteArgsDefaultTypeInternal;
extern RequestVoteArgsDefaultTypeInternal _RequestVoteArgs_default_instance_;
class RequestVoteReply;
struct RequestVoteReplyDefaultTypeInternal;
extern RequestVoteReplyDefaultTypeInternal _RequestVoteReply_default_instance_;
class SnapshotMessage;
struct SnapshotMessageDefaultTypeInternal;
extern SnapshotMessageDefaultTypeInternal _SnapshotMessage_default_instance_;
}  // namespace RaftMes
PROTOBUF_NAMESPACE_OPEN
template<> ::RaftMes::AppendEntriesArgs* Arena::CreateMaybeMessage<::RaftMes::AppendEntriesArgs>(Arena*);
template<> ::RaftMes::AppendEntriesReply* Arena::CreateMaybeMessage<::RaftMes::AppendEntriesReply>(Arena*);
template<> ::RaftMes::ApplyMessage* Arena::CreateMaybeMessage<::RaftMes::ApplyMessage>(Arena*);
template<> ::RaftMes::InstallSnapshotArgs* Arena::CreateMaybeMessage<::RaftMes::InstallSnapshotArgs>(Arena*);
template<> ::RaftMes::InstallSnapshotReply* Arena::CreateMaybeMessage<::RaftMes::InstallSnapshotReply>(Arena*);
template<> ::RaftMes::Log* Arena::CreateMaybeMessage<::RaftMes::Log>(Arena*);
template<> ::RaftMes::LogEntry* Arena::CreateMaybeMessage<::RaftMes::LogEntry>(Arena*);
template<> ::RaftMes::RaftNode* Arena::CreateMaybeMessage<::RaftMes::RaftNode>(Arena*);
template<> ::RaftMes::RequestVoteArgs* Arena::CreateMaybeMessage<::RaftMes::RequestVoteArgs>(Arena*);
template<> ::RaftMes::RequestVoteReply* Arena::CreateMaybeMessage<::RaftMes::RequestVoteReply>(Arena*);
template<> ::RaftMes::SnapshotMessage* Arena::CreateMaybeMessage<::RaftMes::SnapshotMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RaftMes {

// ===================================================================

class RaftNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.RaftNode) */ {
 public:
  inline RaftNode() : RaftNode(nullptr) {}
  ~RaftNode() override;
  explicit constexpr RaftNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftNode(const RaftNode& from);
  RaftNode(RaftNode&& from) noexcept
    : RaftNode() {
    *this = ::std::move(from);
  }

  inline RaftNode& operator=(const RaftNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftNode& operator=(RaftNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftNode* internal_default_instance() {
    return reinterpret_cast<const RaftNode*>(
               &_RaftNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RaftNode& a, RaftNode& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.RaftNode";
  }
  protected:
  explicit RaftNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIPFieldNumber = 1,
    kTermFieldNumber = 3,
    kPortFieldNumber = 2,
    kSelfRoleFieldNumber = 4,
  };
  // string IP = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // uint64 Term = 3;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint32 Port = 2;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // uint32 self_role = 4;
  void clear_self_role();
  uint32_t self_role() const;
  void set_self_role(uint32_t value);
  private:
  uint32_t _internal_self_role() const;
  void _internal_set_self_role(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.RaftNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  uint64_t term_;
  uint32_t port_;
  uint32_t self_role_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  explicit constexpr LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
    kTermFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  // string Command = 1;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // uint64 Term = 2;
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // uint64 Index = 3;
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.LogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  uint64_t term_;
  uint64_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class Log final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  explicit constexpr Log(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Log(const Log& from);
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Log& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.Log";
  }
  protected:
  explicit Log(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kLastIncludedIndexFieldNumber = 2,
    kLastIncludedTermFieldNumber = 3,
  };
  // repeated .RaftMes.LogEntry Entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::RaftMes::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >*
      mutable_entries();
  private:
  const ::RaftMes::LogEntry& _internal_entries(int index) const;
  ::RaftMes::LogEntry* _internal_add_entries();
  public:
  const ::RaftMes::LogEntry& entries(int index) const;
  ::RaftMes::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >&
      entries() const;

  // uint64 LastIncludedIndex = 2;
  void clear_lastincludedindex();
  uint64_t lastincludedindex() const;
  void set_lastincludedindex(uint64_t value);
  private:
  uint64_t _internal_lastincludedindex() const;
  void _internal_set_lastincludedindex(uint64_t value);
  public:

  // uint64 LastIncludedTerm = 3;
  void clear_lastincludedterm();
  uint64_t lastincludedterm() const;
  void set_lastincludedterm(uint64_t value);
  private:
  uint64_t _internal_lastincludedterm() const;
  void _internal_set_lastincludedterm(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.Log)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry > entries_;
  uint64_t lastincludedindex_;
  uint64_t lastincludedterm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.RequestVoteArgs) */ {
 public:
  inline RequestVoteArgs() : RequestVoteArgs(nullptr) {}
  ~RequestVoteArgs() override;
  explicit constexpr RequestVoteArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteArgs(const RequestVoteArgs& from);
  RequestVoteArgs(RequestVoteArgs&& from) noexcept
    : RequestVoteArgs() {
    *this = ::std::move(from);
  }

  inline RequestVoteArgs& operator=(const RequestVoteArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteArgs& operator=(RequestVoteArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteArgs* internal_default_instance() {
    return reinterpret_cast<const RequestVoteArgs*>(
               &_RequestVoteArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestVoteArgs& a, RequestVoteArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.RequestVoteArgs";
  }
  protected:
  explicit RequestVoteArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kLastLogIndexFieldNumber = 2,
    kLastLogTermFieldNumber = 3,
  };
  // .RaftMes.RaftNode node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::RaftMes::RaftNode& node() const;
  PROTOBUF_NODISCARD ::RaftMes::RaftNode* release_node();
  ::RaftMes::RaftNode* mutable_node();
  void set_allocated_node(::RaftMes::RaftNode* node);
  private:
  const ::RaftMes::RaftNode& _internal_node() const;
  ::RaftMes::RaftNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::RaftMes::RaftNode* node);
  ::RaftMes::RaftNode* unsafe_arena_release_node();

  // uint64 LastLogIndex = 2;
  void clear_lastlogindex();
  uint64_t lastlogindex() const;
  void set_lastlogindex(uint64_t value);
  private:
  uint64_t _internal_lastlogindex() const;
  void _internal_set_lastlogindex(uint64_t value);
  public:

  // uint64 LastLogTerm = 3;
  void clear_lastlogterm();
  uint64_t lastlogterm() const;
  void set_lastlogterm(uint64_t value);
  private:
  uint64_t _internal_lastlogterm() const;
  void _internal_set_lastlogterm(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.RequestVoteArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RaftMes::RaftNode* node_;
  uint64_t lastlogindex_;
  uint64_t lastlogterm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.RequestVoteReply) */ {
 public:
  inline RequestVoteReply() : RequestVoteReply(nullptr) {}
  ~RequestVoteReply() override;
  explicit constexpr RequestVoteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteReply(const RequestVoteReply& from);
  RequestVoteReply(RequestVoteReply&& from) noexcept
    : RequestVoteReply() {
    *this = ::std::move(from);
  }

  inline RequestVoteReply& operator=(const RequestVoteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteReply& operator=(RequestVoteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteReply* internal_default_instance() {
    return reinterpret_cast<const RequestVoteReply*>(
               &_RequestVoteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestVoteReply& a, RequestVoteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestVoteReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.RequestVoteReply";
  }
  protected:
  explicit RequestVoteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kVoteGrantedFieldNumber = 3,
  };
  // .RaftMes.RaftNode node = 2;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::RaftMes::RaftNode& node() const;
  PROTOBUF_NODISCARD ::RaftMes::RaftNode* release_node();
  ::RaftMes::RaftNode* mutable_node();
  void set_allocated_node(::RaftMes::RaftNode* node);
  private:
  const ::RaftMes::RaftNode& _internal_node() const;
  ::RaftMes::RaftNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::RaftMes::RaftNode* node);
  ::RaftMes::RaftNode* unsafe_arena_release_node();

  // bool voteGranted = 3;
  void clear_votegranted();
  bool votegranted() const;
  void set_votegranted(bool value);
  private:
  bool _internal_votegranted() const;
  void _internal_set_votegranted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.RequestVoteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RaftMes::RaftNode* node_;
  bool votegranted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.AppendEntriesArgs) */ {
 public:
  inline AppendEntriesArgs() : AppendEntriesArgs(nullptr) {}
  ~AppendEntriesArgs() override;
  explicit constexpr AppendEntriesArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesArgs(const AppendEntriesArgs& from);
  AppendEntriesArgs(AppendEntriesArgs&& from) noexcept
    : AppendEntriesArgs() {
    *this = ::std::move(from);
  }

  inline AppendEntriesArgs& operator=(const AppendEntriesArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesArgs& operator=(AppendEntriesArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesArgs* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesArgs*>(
               &_AppendEntriesArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AppendEntriesArgs& a, AppendEntriesArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntriesArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.AppendEntriesArgs";
  }
  protected:
  explicit AppendEntriesArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 5,
    kNodeFieldNumber = 1,
    kPrevLogIndexFieldNumber = 2,
    kPrevLogTermFieldNumber = 3,
    kLeaderCommitIndexFieldNumber = 4,
  };
  // repeated .RaftMes.LogEntry Entries = 5;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::RaftMes::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >*
      mutable_entries();
  private:
  const ::RaftMes::LogEntry& _internal_entries(int index) const;
  ::RaftMes::LogEntry* _internal_add_entries();
  public:
  const ::RaftMes::LogEntry& entries(int index) const;
  ::RaftMes::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >&
      entries() const;

  // .RaftMes.RaftNode node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::RaftMes::RaftNode& node() const;
  PROTOBUF_NODISCARD ::RaftMes::RaftNode* release_node();
  ::RaftMes::RaftNode* mutable_node();
  void set_allocated_node(::RaftMes::RaftNode* node);
  private:
  const ::RaftMes::RaftNode& _internal_node() const;
  ::RaftMes::RaftNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::RaftMes::RaftNode* node);
  ::RaftMes::RaftNode* unsafe_arena_release_node();

  // uint64 PrevLogIndex = 2;
  void clear_prevlogindex();
  uint64_t prevlogindex() const;
  void set_prevlogindex(uint64_t value);
  private:
  uint64_t _internal_prevlogindex() const;
  void _internal_set_prevlogindex(uint64_t value);
  public:

  // uint64 PrevLogTerm = 3;
  void clear_prevlogterm();
  uint64_t prevlogterm() const;
  void set_prevlogterm(uint64_t value);
  private:
  uint64_t _internal_prevlogterm() const;
  void _internal_set_prevlogterm(uint64_t value);
  public:

  // uint64 LeaderCommitIndex = 4;
  void clear_leadercommitindex();
  uint64_t leadercommitindex() const;
  void set_leadercommitindex(uint64_t value);
  private:
  uint64_t _internal_leadercommitindex() const;
  void _internal_set_leadercommitindex(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.AppendEntriesArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry > entries_;
  ::RaftMes::RaftNode* node_;
  uint64_t prevlogindex_;
  uint64_t prevlogterm_;
  uint64_t leadercommitindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.AppendEntriesReply) */ {
 public:
  inline AppendEntriesReply() : AppendEntriesReply(nullptr) {}
  ~AppendEntriesReply() override;
  explicit constexpr AppendEntriesReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesReply(const AppendEntriesReply& from);
  AppendEntriesReply(AppendEntriesReply&& from) noexcept
    : AppendEntriesReply() {
    *this = ::std::move(from);
  }

  inline AppendEntriesReply& operator=(const AppendEntriesReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesReply& operator=(AppendEntriesReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesReply* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesReply*>(
               &_AppendEntriesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AppendEntriesReply& a, AppendEntriesReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppendEntriesReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.AppendEntriesReply";
  }
  protected:
  explicit AppendEntriesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kUnmatchIndexFieldNumber = 3,
    kUnmatchTermFieldNumber = 4,
    kOkFieldNumber = 2,
  };
  // .RaftMes.RaftNode node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::RaftMes::RaftNode& node() const;
  PROTOBUF_NODISCARD ::RaftMes::RaftNode* release_node();
  ::RaftMes::RaftNode* mutable_node();
  void set_allocated_node(::RaftMes::RaftNode* node);
  private:
  const ::RaftMes::RaftNode& _internal_node() const;
  ::RaftMes::RaftNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::RaftMes::RaftNode* node);
  ::RaftMes::RaftNode* unsafe_arena_release_node();

  // uint64 UnmatchIndex = 3;
  void clear_unmatchindex();
  uint64_t unmatchindex() const;
  void set_unmatchindex(uint64_t value);
  private:
  uint64_t _internal_unmatchindex() const;
  void _internal_set_unmatchindex(uint64_t value);
  public:

  // uint64 UnmatchTerm = 4;
  void clear_unmatchterm();
  uint64_t unmatchterm() const;
  void set_unmatchterm(uint64_t value);
  private:
  uint64_t _internal_unmatchterm() const;
  void _internal_set_unmatchterm(uint64_t value);
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.AppendEntriesReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RaftMes::RaftNode* node_;
  uint64_t unmatchindex_;
  uint64_t unmatchterm_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class InstallSnapshotArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.InstallSnapshotArgs) */ {
 public:
  inline InstallSnapshotArgs() : InstallSnapshotArgs(nullptr) {}
  ~InstallSnapshotArgs() override;
  explicit constexpr InstallSnapshotArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallSnapshotArgs(const InstallSnapshotArgs& from);
  InstallSnapshotArgs(InstallSnapshotArgs&& from) noexcept
    : InstallSnapshotArgs() {
    *this = ::std::move(from);
  }

  inline InstallSnapshotArgs& operator=(const InstallSnapshotArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSnapshotArgs& operator=(InstallSnapshotArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSnapshotArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSnapshotArgs* internal_default_instance() {
    return reinterpret_cast<const InstallSnapshotArgs*>(
               &_InstallSnapshotArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InstallSnapshotArgs& a, InstallSnapshotArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallSnapshotArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSnapshotArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSnapshotArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallSnapshotArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallSnapshotArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstallSnapshotArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallSnapshotArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.InstallSnapshotArgs";
  }
  protected:
  explicit InstallSnapshotArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kNodeFieldNumber = 1,
    kLastIncludedIndexFieldNumber = 2,
    kLastIncludedTermFieldNumber = 3,
  };
  // string Data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .RaftMes.RaftNode node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::RaftMes::RaftNode& node() const;
  PROTOBUF_NODISCARD ::RaftMes::RaftNode* release_node();
  ::RaftMes::RaftNode* mutable_node();
  void set_allocated_node(::RaftMes::RaftNode* node);
  private:
  const ::RaftMes::RaftNode& _internal_node() const;
  ::RaftMes::RaftNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::RaftMes::RaftNode* node);
  ::RaftMes::RaftNode* unsafe_arena_release_node();

  // uint64 LastIncludedIndex = 2;
  void clear_lastincludedindex();
  uint64_t lastincludedindex() const;
  void set_lastincludedindex(uint64_t value);
  private:
  uint64_t _internal_lastincludedindex() const;
  void _internal_set_lastincludedindex(uint64_t value);
  public:

  // uint64 LastIncludedTerm = 3;
  void clear_lastincludedterm();
  uint64_t lastincludedterm() const;
  void set_lastincludedterm(uint64_t value);
  private:
  uint64_t _internal_lastincludedterm() const;
  void _internal_set_lastincludedterm(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.InstallSnapshotArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::RaftMes::RaftNode* node_;
  uint64_t lastincludedindex_;
  uint64_t lastincludedterm_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class InstallSnapshotReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.InstallSnapshotReply) */ {
 public:
  inline InstallSnapshotReply() : InstallSnapshotReply(nullptr) {}
  ~InstallSnapshotReply() override;
  explicit constexpr InstallSnapshotReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallSnapshotReply(const InstallSnapshotReply& from);
  InstallSnapshotReply(InstallSnapshotReply&& from) noexcept
    : InstallSnapshotReply() {
    *this = ::std::move(from);
  }

  inline InstallSnapshotReply& operator=(const InstallSnapshotReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallSnapshotReply& operator=(InstallSnapshotReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallSnapshotReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallSnapshotReply* internal_default_instance() {
    return reinterpret_cast<const InstallSnapshotReply*>(
               &_InstallSnapshotReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InstallSnapshotReply& a, InstallSnapshotReply& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallSnapshotReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallSnapshotReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallSnapshotReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallSnapshotReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallSnapshotReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstallSnapshotReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallSnapshotReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.InstallSnapshotReply";
  }
  protected:
  explicit InstallSnapshotReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
  };
  // .RaftMes.RaftNode node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::RaftMes::RaftNode& node() const;
  PROTOBUF_NODISCARD ::RaftMes::RaftNode* release_node();
  ::RaftMes::RaftNode* mutable_node();
  void set_allocated_node(::RaftMes::RaftNode* node);
  private:
  const ::RaftMes::RaftNode& _internal_node() const;
  ::RaftMes::RaftNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::RaftMes::RaftNode* node);
  ::RaftMes::RaftNode* unsafe_arena_release_node();

  // @@protoc_insertion_point(class_scope:RaftMes.InstallSnapshotReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::RaftMes::RaftNode* node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class SnapshotMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.SnapshotMessage) */ {
 public:
  inline SnapshotMessage() : SnapshotMessage(nullptr) {}
  ~SnapshotMessage() override;
  explicit constexpr SnapshotMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotMessage(const SnapshotMessage& from);
  SnapshotMessage(SnapshotMessage&& from) noexcept
    : SnapshotMessage() {
    *this = ::std::move(from);
  }

  inline SnapshotMessage& operator=(const SnapshotMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotMessage& operator=(SnapshotMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotMessage* internal_default_instance() {
    return reinterpret_cast<const SnapshotMessage*>(
               &_SnapshotMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SnapshotMessage& a, SnapshotMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SnapshotMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.SnapshotMessage";
  }
  protected:
  explicit SnapshotMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 2,
    kSnapshotTermFieldNumber = 3,
    kSnapshotIndexFieldNumber = 4,
    kSnapshotValidFieldNumber = 1,
  };
  // string Snapshot = 2;
  void clear_snapshot();
  const std::string& snapshot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snapshot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snapshot();
  PROTOBUF_NODISCARD std::string* release_snapshot();
  void set_allocated_snapshot(std::string* snapshot);
  private:
  const std::string& _internal_snapshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot(const std::string& value);
  std::string* _internal_mutable_snapshot();
  public:

  // uint64 SnapshotTerm = 3;
  void clear_snapshotterm();
  uint64_t snapshotterm() const;
  void set_snapshotterm(uint64_t value);
  private:
  uint64_t _internal_snapshotterm() const;
  void _internal_set_snapshotterm(uint64_t value);
  public:

  // uint64 SnapshotIndex = 4;
  void clear_snapshotindex();
  uint64_t snapshotindex() const;
  void set_snapshotindex(uint64_t value);
  private:
  uint64_t _internal_snapshotindex() const;
  void _internal_set_snapshotindex(uint64_t value);
  public:

  // bool SnapshotValid = 1;
  void clear_snapshotvalid();
  bool snapshotvalid() const;
  void set_snapshotvalid(bool value);
  private:
  bool _internal_snapshotvalid() const;
  void _internal_set_snapshotvalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.SnapshotMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_;
  uint64_t snapshotterm_;
  uint64_t snapshotindex_;
  bool snapshotvalid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class ApplyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RaftMes.ApplyMessage) */ {
 public:
  inline ApplyMessage() : ApplyMessage(nullptr) {}
  ~ApplyMessage() override;
  explicit constexpr ApplyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyMessage(const ApplyMessage& from);
  ApplyMessage(ApplyMessage&& from) noexcept
    : ApplyMessage() {
    *this = ::std::move(from);
  }

  inline ApplyMessage& operator=(const ApplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyMessage& operator=(ApplyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyMessage* internal_default_instance() {
    return reinterpret_cast<const ApplyMessage*>(
               &_ApplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ApplyMessage& a, ApplyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RaftMes.ApplyMessage";
  }
  protected:
  explicit ApplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 2,
    kSnapshotFieldNumber = 5,
    kCommandIndexFieldNumber = 3,
    kCommandTermFieldNumber = 4,
    kCommandVaildFieldNumber = 1,
  };
  // string Command = 2;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // optional .RaftMes.SnapshotMessage snapshot = 5;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::RaftMes::SnapshotMessage& snapshot() const;
  PROTOBUF_NODISCARD ::RaftMes::SnapshotMessage* release_snapshot();
  ::RaftMes::SnapshotMessage* mutable_snapshot();
  void set_allocated_snapshot(::RaftMes::SnapshotMessage* snapshot);
  private:
  const ::RaftMes::SnapshotMessage& _internal_snapshot() const;
  ::RaftMes::SnapshotMessage* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::RaftMes::SnapshotMessage* snapshot);
  ::RaftMes::SnapshotMessage* unsafe_arena_release_snapshot();

  // uint64 CommandIndex = 3;
  void clear_commandindex();
  uint64_t commandindex() const;
  void set_commandindex(uint64_t value);
  private:
  uint64_t _internal_commandindex() const;
  void _internal_set_commandindex(uint64_t value);
  public:

  // uint64 CommandTerm = 4;
  void clear_commandterm();
  uint64_t commandterm() const;
  void set_commandterm(uint64_t value);
  private:
  uint64_t _internal_commandterm() const;
  void _internal_set_commandterm(uint64_t value);
  public:

  // bool CommandVaild = 1;
  void clear_commandvaild();
  bool commandvaild() const;
  void set_commandvaild(bool value);
  private:
  bool _internal_commandvaild() const;
  void _internal_set_commandvaild(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RaftMes.ApplyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  ::RaftMes::SnapshotMessage* snapshot_;
  uint64_t commandindex_;
  uint64_t commandterm_;
  bool commandvaild_;
  friend struct ::TableStruct_raft_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RaftNode

// string IP = 1;
inline void RaftNode::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& RaftNode::ip() const {
  // @@protoc_insertion_point(field_get:RaftMes.RaftNode.IP)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RaftNode::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftMes.RaftNode.IP)
}
inline std::string* RaftNode::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:RaftMes.RaftNode.IP)
  return _s;
}
inline const std::string& RaftNode::_internal_ip() const {
  return ip_.Get();
}
inline void RaftNode::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RaftNode::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RaftNode::release_ip() {
  // @@protoc_insertion_point(field_release:RaftMes.RaftNode.IP)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RaftNode::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RaftMes.RaftNode.IP)
}

// uint32 Port = 2;
inline void RaftNode::clear_port() {
  port_ = 0u;
}
inline uint32_t RaftNode::_internal_port() const {
  return port_;
}
inline uint32_t RaftNode::port() const {
  // @@protoc_insertion_point(field_get:RaftMes.RaftNode.Port)
  return _internal_port();
}
inline void RaftNode::_internal_set_port(uint32_t value) {
  
  port_ = value;
}
inline void RaftNode::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:RaftMes.RaftNode.Port)
}

// uint64 Term = 3;
inline void RaftNode::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t RaftNode::_internal_term() const {
  return term_;
}
inline uint64_t RaftNode::term() const {
  // @@protoc_insertion_point(field_get:RaftMes.RaftNode.Term)
  return _internal_term();
}
inline void RaftNode::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void RaftNode::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RaftMes.RaftNode.Term)
}

// uint32 self_role = 4;
inline void RaftNode::clear_self_role() {
  self_role_ = 0u;
}
inline uint32_t RaftNode::_internal_self_role() const {
  return self_role_;
}
inline uint32_t RaftNode::self_role() const {
  // @@protoc_insertion_point(field_get:RaftMes.RaftNode.self_role)
  return _internal_self_role();
}
inline void RaftNode::_internal_set_self_role(uint32_t value) {
  
  self_role_ = value;
}
inline void RaftNode::set_self_role(uint32_t value) {
  _internal_set_self_role(value);
  // @@protoc_insertion_point(field_set:RaftMes.RaftNode.self_role)
}

// -------------------------------------------------------------------

// LogEntry

// string Command = 1;
inline void LogEntry::clear_command() {
  command_.ClearToEmpty();
}
inline const std::string& LogEntry::command() const {
  // @@protoc_insertion_point(field_get:RaftMes.LogEntry.Command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_command(ArgT0&& arg0, ArgT... args) {
 
 command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftMes.LogEntry.Command)
}
inline std::string* LogEntry::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:RaftMes.LogEntry.Command)
  return _s;
}
inline const std::string& LogEntry::_internal_command() const {
  return command_.Get();
}
inline void LogEntry::_internal_set_command(const std::string& value) {
  
  command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_command() {
  
  return command_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogEntry::release_command() {
  // @@protoc_insertion_point(field_release:RaftMes.LogEntry.Command)
  return command_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LogEntry::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (command_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RaftMes.LogEntry.Command)
}

// uint64 Term = 2;
inline void LogEntry::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t LogEntry::_internal_term() const {
  return term_;
}
inline uint64_t LogEntry::term() const {
  // @@protoc_insertion_point(field_get:RaftMes.LogEntry.Term)
  return _internal_term();
}
inline void LogEntry::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void LogEntry::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:RaftMes.LogEntry.Term)
}

// uint64 Index = 3;
inline void LogEntry::clear_index() {
  index_ = uint64_t{0u};
}
inline uint64_t LogEntry::_internal_index() const {
  return index_;
}
inline uint64_t LogEntry::index() const {
  // @@protoc_insertion_point(field_get:RaftMes.LogEntry.Index)
  return _internal_index();
}
inline void LogEntry::_internal_set_index(uint64_t value) {
  
  index_ = value;
}
inline void LogEntry::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:RaftMes.LogEntry.Index)
}

// -------------------------------------------------------------------

// Log

// repeated .RaftMes.LogEntry Entries = 1;
inline int Log::_internal_entries_size() const {
  return entries_.size();
}
inline int Log::entries_size() const {
  return _internal_entries_size();
}
inline void Log::clear_entries() {
  entries_.Clear();
}
inline ::RaftMes::LogEntry* Log::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:RaftMes.Log.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >*
Log::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:RaftMes.Log.Entries)
  return &entries_;
}
inline const ::RaftMes::LogEntry& Log::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::RaftMes::LogEntry& Log::entries(int index) const {
  // @@protoc_insertion_point(field_get:RaftMes.Log.Entries)
  return _internal_entries(index);
}
inline ::RaftMes::LogEntry* Log::_internal_add_entries() {
  return entries_.Add();
}
inline ::RaftMes::LogEntry* Log::add_entries() {
  ::RaftMes::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:RaftMes.Log.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >&
Log::entries() const {
  // @@protoc_insertion_point(field_list:RaftMes.Log.Entries)
  return entries_;
}

// uint64 LastIncludedIndex = 2;
inline void Log::clear_lastincludedindex() {
  lastincludedindex_ = uint64_t{0u};
}
inline uint64_t Log::_internal_lastincludedindex() const {
  return lastincludedindex_;
}
inline uint64_t Log::lastincludedindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.Log.LastIncludedIndex)
  return _internal_lastincludedindex();
}
inline void Log::_internal_set_lastincludedindex(uint64_t value) {
  
  lastincludedindex_ = value;
}
inline void Log::set_lastincludedindex(uint64_t value) {
  _internal_set_lastincludedindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.Log.LastIncludedIndex)
}

// uint64 LastIncludedTerm = 3;
inline void Log::clear_lastincludedterm() {
  lastincludedterm_ = uint64_t{0u};
}
inline uint64_t Log::_internal_lastincludedterm() const {
  return lastincludedterm_;
}
inline uint64_t Log::lastincludedterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.Log.LastIncludedTerm)
  return _internal_lastincludedterm();
}
inline void Log::_internal_set_lastincludedterm(uint64_t value) {
  
  lastincludedterm_ = value;
}
inline void Log::set_lastincludedterm(uint64_t value) {
  _internal_set_lastincludedterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.Log.LastIncludedTerm)
}

// -------------------------------------------------------------------

// RequestVoteArgs

// .RaftMes.RaftNode node = 1;
inline bool RequestVoteArgs::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool RequestVoteArgs::has_node() const {
  return _internal_has_node();
}
inline void RequestVoteArgs::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::RaftMes::RaftNode& RequestVoteArgs::_internal_node() const {
  const ::RaftMes::RaftNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::RaftNode&>(
      ::RaftMes::_RaftNode_default_instance_);
}
inline const ::RaftMes::RaftNode& RequestVoteArgs::node() const {
  // @@protoc_insertion_point(field_get:RaftMes.RequestVoteArgs.node)
  return _internal_node();
}
inline void RequestVoteArgs::unsafe_arena_set_allocated_node(
    ::RaftMes::RaftNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.RequestVoteArgs.node)
}
inline ::RaftMes::RaftNode* RequestVoteArgs::release_node() {
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::RaftNode* RequestVoteArgs::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:RaftMes.RequestVoteArgs.node)
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::RaftMes::RaftNode* RequestVoteArgs::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::RaftNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::RaftMes::RaftNode* RequestVoteArgs::mutable_node() {
  ::RaftMes::RaftNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:RaftMes.RequestVoteArgs.node)
  return _msg;
}
inline void RequestVoteArgs::set_allocated_node(::RaftMes::RaftNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::RaftNode>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.RequestVoteArgs.node)
}

// uint64 LastLogIndex = 2;
inline void RequestVoteArgs::clear_lastlogindex() {
  lastlogindex_ = uint64_t{0u};
}
inline uint64_t RequestVoteArgs::_internal_lastlogindex() const {
  return lastlogindex_;
}
inline uint64_t RequestVoteArgs::lastlogindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.RequestVoteArgs.LastLogIndex)
  return _internal_lastlogindex();
}
inline void RequestVoteArgs::_internal_set_lastlogindex(uint64_t value) {
  
  lastlogindex_ = value;
}
inline void RequestVoteArgs::set_lastlogindex(uint64_t value) {
  _internal_set_lastlogindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.RequestVoteArgs.LastLogIndex)
}

// uint64 LastLogTerm = 3;
inline void RequestVoteArgs::clear_lastlogterm() {
  lastlogterm_ = uint64_t{0u};
}
inline uint64_t RequestVoteArgs::_internal_lastlogterm() const {
  return lastlogterm_;
}
inline uint64_t RequestVoteArgs::lastlogterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.RequestVoteArgs.LastLogTerm)
  return _internal_lastlogterm();
}
inline void RequestVoteArgs::_internal_set_lastlogterm(uint64_t value) {
  
  lastlogterm_ = value;
}
inline void RequestVoteArgs::set_lastlogterm(uint64_t value) {
  _internal_set_lastlogterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.RequestVoteArgs.LastLogTerm)
}

// -------------------------------------------------------------------

// RequestVoteReply

// .RaftMes.RaftNode node = 2;
inline bool RequestVoteReply::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool RequestVoteReply::has_node() const {
  return _internal_has_node();
}
inline void RequestVoteReply::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::RaftMes::RaftNode& RequestVoteReply::_internal_node() const {
  const ::RaftMes::RaftNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::RaftNode&>(
      ::RaftMes::_RaftNode_default_instance_);
}
inline const ::RaftMes::RaftNode& RequestVoteReply::node() const {
  // @@protoc_insertion_point(field_get:RaftMes.RequestVoteReply.node)
  return _internal_node();
}
inline void RequestVoteReply::unsafe_arena_set_allocated_node(
    ::RaftMes::RaftNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.RequestVoteReply.node)
}
inline ::RaftMes::RaftNode* RequestVoteReply::release_node() {
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::RaftNode* RequestVoteReply::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:RaftMes.RequestVoteReply.node)
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::RaftMes::RaftNode* RequestVoteReply::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::RaftNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::RaftMes::RaftNode* RequestVoteReply::mutable_node() {
  ::RaftMes::RaftNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:RaftMes.RequestVoteReply.node)
  return _msg;
}
inline void RequestVoteReply::set_allocated_node(::RaftMes::RaftNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::RaftNode>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.RequestVoteReply.node)
}

// bool voteGranted = 3;
inline void RequestVoteReply::clear_votegranted() {
  votegranted_ = false;
}
inline bool RequestVoteReply::_internal_votegranted() const {
  return votegranted_;
}
inline bool RequestVoteReply::votegranted() const {
  // @@protoc_insertion_point(field_get:RaftMes.RequestVoteReply.voteGranted)
  return _internal_votegranted();
}
inline void RequestVoteReply::_internal_set_votegranted(bool value) {
  
  votegranted_ = value;
}
inline void RequestVoteReply::set_votegranted(bool value) {
  _internal_set_votegranted(value);
  // @@protoc_insertion_point(field_set:RaftMes.RequestVoteReply.voteGranted)
}

// -------------------------------------------------------------------

// AppendEntriesArgs

// .RaftMes.RaftNode node = 1;
inline bool AppendEntriesArgs::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool AppendEntriesArgs::has_node() const {
  return _internal_has_node();
}
inline void AppendEntriesArgs::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::RaftMes::RaftNode& AppendEntriesArgs::_internal_node() const {
  const ::RaftMes::RaftNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::RaftNode&>(
      ::RaftMes::_RaftNode_default_instance_);
}
inline const ::RaftMes::RaftNode& AppendEntriesArgs::node() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesArgs.node)
  return _internal_node();
}
inline void AppendEntriesArgs::unsafe_arena_set_allocated_node(
    ::RaftMes::RaftNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.AppendEntriesArgs.node)
}
inline ::RaftMes::RaftNode* AppendEntriesArgs::release_node() {
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::RaftNode* AppendEntriesArgs::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:RaftMes.AppendEntriesArgs.node)
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::RaftMes::RaftNode* AppendEntriesArgs::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::RaftNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::RaftMes::RaftNode* AppendEntriesArgs::mutable_node() {
  ::RaftMes::RaftNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:RaftMes.AppendEntriesArgs.node)
  return _msg;
}
inline void AppendEntriesArgs::set_allocated_node(::RaftMes::RaftNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::RaftNode>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.AppendEntriesArgs.node)
}

// uint64 PrevLogIndex = 2;
inline void AppendEntriesArgs::clear_prevlogindex() {
  prevlogindex_ = uint64_t{0u};
}
inline uint64_t AppendEntriesArgs::_internal_prevlogindex() const {
  return prevlogindex_;
}
inline uint64_t AppendEntriesArgs::prevlogindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesArgs.PrevLogIndex)
  return _internal_prevlogindex();
}
inline void AppendEntriesArgs::_internal_set_prevlogindex(uint64_t value) {
  
  prevlogindex_ = value;
}
inline void AppendEntriesArgs::set_prevlogindex(uint64_t value) {
  _internal_set_prevlogindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.AppendEntriesArgs.PrevLogIndex)
}

// uint64 PrevLogTerm = 3;
inline void AppendEntriesArgs::clear_prevlogterm() {
  prevlogterm_ = uint64_t{0u};
}
inline uint64_t AppendEntriesArgs::_internal_prevlogterm() const {
  return prevlogterm_;
}
inline uint64_t AppendEntriesArgs::prevlogterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesArgs.PrevLogTerm)
  return _internal_prevlogterm();
}
inline void AppendEntriesArgs::_internal_set_prevlogterm(uint64_t value) {
  
  prevlogterm_ = value;
}
inline void AppendEntriesArgs::set_prevlogterm(uint64_t value) {
  _internal_set_prevlogterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.AppendEntriesArgs.PrevLogTerm)
}

// uint64 LeaderCommitIndex = 4;
inline void AppendEntriesArgs::clear_leadercommitindex() {
  leadercommitindex_ = uint64_t{0u};
}
inline uint64_t AppendEntriesArgs::_internal_leadercommitindex() const {
  return leadercommitindex_;
}
inline uint64_t AppendEntriesArgs::leadercommitindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesArgs.LeaderCommitIndex)
  return _internal_leadercommitindex();
}
inline void AppendEntriesArgs::_internal_set_leadercommitindex(uint64_t value) {
  
  leadercommitindex_ = value;
}
inline void AppendEntriesArgs::set_leadercommitindex(uint64_t value) {
  _internal_set_leadercommitindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.AppendEntriesArgs.LeaderCommitIndex)
}

// repeated .RaftMes.LogEntry Entries = 5;
inline int AppendEntriesArgs::_internal_entries_size() const {
  return entries_.size();
}
inline int AppendEntriesArgs::entries_size() const {
  return _internal_entries_size();
}
inline void AppendEntriesArgs::clear_entries() {
  entries_.Clear();
}
inline ::RaftMes::LogEntry* AppendEntriesArgs::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:RaftMes.AppendEntriesArgs.Entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >*
AppendEntriesArgs::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:RaftMes.AppendEntriesArgs.Entries)
  return &entries_;
}
inline const ::RaftMes::LogEntry& AppendEntriesArgs::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::RaftMes::LogEntry& AppendEntriesArgs::entries(int index) const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesArgs.Entries)
  return _internal_entries(index);
}
inline ::RaftMes::LogEntry* AppendEntriesArgs::_internal_add_entries() {
  return entries_.Add();
}
inline ::RaftMes::LogEntry* AppendEntriesArgs::add_entries() {
  ::RaftMes::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:RaftMes.AppendEntriesArgs.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RaftMes::LogEntry >&
AppendEntriesArgs::entries() const {
  // @@protoc_insertion_point(field_list:RaftMes.AppendEntriesArgs.Entries)
  return entries_;
}

// -------------------------------------------------------------------

// AppendEntriesReply

// .RaftMes.RaftNode node = 1;
inline bool AppendEntriesReply::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool AppendEntriesReply::has_node() const {
  return _internal_has_node();
}
inline void AppendEntriesReply::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::RaftMes::RaftNode& AppendEntriesReply::_internal_node() const {
  const ::RaftMes::RaftNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::RaftNode&>(
      ::RaftMes::_RaftNode_default_instance_);
}
inline const ::RaftMes::RaftNode& AppendEntriesReply::node() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesReply.node)
  return _internal_node();
}
inline void AppendEntriesReply::unsafe_arena_set_allocated_node(
    ::RaftMes::RaftNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.AppendEntriesReply.node)
}
inline ::RaftMes::RaftNode* AppendEntriesReply::release_node() {
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::RaftNode* AppendEntriesReply::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:RaftMes.AppendEntriesReply.node)
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::RaftMes::RaftNode* AppendEntriesReply::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::RaftNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::RaftMes::RaftNode* AppendEntriesReply::mutable_node() {
  ::RaftMes::RaftNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:RaftMes.AppendEntriesReply.node)
  return _msg;
}
inline void AppendEntriesReply::set_allocated_node(::RaftMes::RaftNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::RaftNode>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.AppendEntriesReply.node)
}

// bool ok = 2;
inline void AppendEntriesReply::clear_ok() {
  ok_ = false;
}
inline bool AppendEntriesReply::_internal_ok() const {
  return ok_;
}
inline bool AppendEntriesReply::ok() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesReply.ok)
  return _internal_ok();
}
inline void AppendEntriesReply::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void AppendEntriesReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:RaftMes.AppendEntriesReply.ok)
}

// uint64 UnmatchIndex = 3;
inline void AppendEntriesReply::clear_unmatchindex() {
  unmatchindex_ = uint64_t{0u};
}
inline uint64_t AppendEntriesReply::_internal_unmatchindex() const {
  return unmatchindex_;
}
inline uint64_t AppendEntriesReply::unmatchindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesReply.UnmatchIndex)
  return _internal_unmatchindex();
}
inline void AppendEntriesReply::_internal_set_unmatchindex(uint64_t value) {
  
  unmatchindex_ = value;
}
inline void AppendEntriesReply::set_unmatchindex(uint64_t value) {
  _internal_set_unmatchindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.AppendEntriesReply.UnmatchIndex)
}

// uint64 UnmatchTerm = 4;
inline void AppendEntriesReply::clear_unmatchterm() {
  unmatchterm_ = uint64_t{0u};
}
inline uint64_t AppendEntriesReply::_internal_unmatchterm() const {
  return unmatchterm_;
}
inline uint64_t AppendEntriesReply::unmatchterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.AppendEntriesReply.UnmatchTerm)
  return _internal_unmatchterm();
}
inline void AppendEntriesReply::_internal_set_unmatchterm(uint64_t value) {
  
  unmatchterm_ = value;
}
inline void AppendEntriesReply::set_unmatchterm(uint64_t value) {
  _internal_set_unmatchterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.AppendEntriesReply.UnmatchTerm)
}

// -------------------------------------------------------------------

// InstallSnapshotArgs

// .RaftMes.RaftNode node = 1;
inline bool InstallSnapshotArgs::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool InstallSnapshotArgs::has_node() const {
  return _internal_has_node();
}
inline void InstallSnapshotArgs::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::RaftMes::RaftNode& InstallSnapshotArgs::_internal_node() const {
  const ::RaftMes::RaftNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::RaftNode&>(
      ::RaftMes::_RaftNode_default_instance_);
}
inline const ::RaftMes::RaftNode& InstallSnapshotArgs::node() const {
  // @@protoc_insertion_point(field_get:RaftMes.InstallSnapshotArgs.node)
  return _internal_node();
}
inline void InstallSnapshotArgs::unsafe_arena_set_allocated_node(
    ::RaftMes::RaftNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.InstallSnapshotArgs.node)
}
inline ::RaftMes::RaftNode* InstallSnapshotArgs::release_node() {
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::RaftNode* InstallSnapshotArgs::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:RaftMes.InstallSnapshotArgs.node)
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::RaftMes::RaftNode* InstallSnapshotArgs::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::RaftNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::RaftMes::RaftNode* InstallSnapshotArgs::mutable_node() {
  ::RaftMes::RaftNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:RaftMes.InstallSnapshotArgs.node)
  return _msg;
}
inline void InstallSnapshotArgs::set_allocated_node(::RaftMes::RaftNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::RaftNode>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.InstallSnapshotArgs.node)
}

// uint64 LastIncludedIndex = 2;
inline void InstallSnapshotArgs::clear_lastincludedindex() {
  lastincludedindex_ = uint64_t{0u};
}
inline uint64_t InstallSnapshotArgs::_internal_lastincludedindex() const {
  return lastincludedindex_;
}
inline uint64_t InstallSnapshotArgs::lastincludedindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.InstallSnapshotArgs.LastIncludedIndex)
  return _internal_lastincludedindex();
}
inline void InstallSnapshotArgs::_internal_set_lastincludedindex(uint64_t value) {
  
  lastincludedindex_ = value;
}
inline void InstallSnapshotArgs::set_lastincludedindex(uint64_t value) {
  _internal_set_lastincludedindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.InstallSnapshotArgs.LastIncludedIndex)
}

// uint64 LastIncludedTerm = 3;
inline void InstallSnapshotArgs::clear_lastincludedterm() {
  lastincludedterm_ = uint64_t{0u};
}
inline uint64_t InstallSnapshotArgs::_internal_lastincludedterm() const {
  return lastincludedterm_;
}
inline uint64_t InstallSnapshotArgs::lastincludedterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.InstallSnapshotArgs.LastIncludedTerm)
  return _internal_lastincludedterm();
}
inline void InstallSnapshotArgs::_internal_set_lastincludedterm(uint64_t value) {
  
  lastincludedterm_ = value;
}
inline void InstallSnapshotArgs::set_lastincludedterm(uint64_t value) {
  _internal_set_lastincludedterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.InstallSnapshotArgs.LastIncludedTerm)
}

// string Data = 4;
inline void InstallSnapshotArgs::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& InstallSnapshotArgs::data() const {
  // @@protoc_insertion_point(field_get:RaftMes.InstallSnapshotArgs.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallSnapshotArgs::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftMes.InstallSnapshotArgs.Data)
}
inline std::string* InstallSnapshotArgs::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:RaftMes.InstallSnapshotArgs.Data)
  return _s;
}
inline const std::string& InstallSnapshotArgs::_internal_data() const {
  return data_.Get();
}
inline void InstallSnapshotArgs::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstallSnapshotArgs::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstallSnapshotArgs::release_data() {
  // @@protoc_insertion_point(field_release:RaftMes.InstallSnapshotArgs.Data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstallSnapshotArgs::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RaftMes.InstallSnapshotArgs.Data)
}

// -------------------------------------------------------------------

// InstallSnapshotReply

// .RaftMes.RaftNode node = 1;
inline bool InstallSnapshotReply::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool InstallSnapshotReply::has_node() const {
  return _internal_has_node();
}
inline void InstallSnapshotReply::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::RaftMes::RaftNode& InstallSnapshotReply::_internal_node() const {
  const ::RaftMes::RaftNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::RaftNode&>(
      ::RaftMes::_RaftNode_default_instance_);
}
inline const ::RaftMes::RaftNode& InstallSnapshotReply::node() const {
  // @@protoc_insertion_point(field_get:RaftMes.InstallSnapshotReply.node)
  return _internal_node();
}
inline void InstallSnapshotReply::unsafe_arena_set_allocated_node(
    ::RaftMes::RaftNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.InstallSnapshotReply.node)
}
inline ::RaftMes::RaftNode* InstallSnapshotReply::release_node() {
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::RaftNode* InstallSnapshotReply::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:RaftMes.InstallSnapshotReply.node)
  
  ::RaftMes::RaftNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::RaftMes::RaftNode* InstallSnapshotReply::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::RaftNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::RaftMes::RaftNode* InstallSnapshotReply::mutable_node() {
  ::RaftMes::RaftNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:RaftMes.InstallSnapshotReply.node)
  return _msg;
}
inline void InstallSnapshotReply::set_allocated_node(::RaftMes::RaftNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::RaftNode>::GetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.InstallSnapshotReply.node)
}

// -------------------------------------------------------------------

// SnapshotMessage

// bool SnapshotValid = 1;
inline void SnapshotMessage::clear_snapshotvalid() {
  snapshotvalid_ = false;
}
inline bool SnapshotMessage::_internal_snapshotvalid() const {
  return snapshotvalid_;
}
inline bool SnapshotMessage::snapshotvalid() const {
  // @@protoc_insertion_point(field_get:RaftMes.SnapshotMessage.SnapshotValid)
  return _internal_snapshotvalid();
}
inline void SnapshotMessage::_internal_set_snapshotvalid(bool value) {
  
  snapshotvalid_ = value;
}
inline void SnapshotMessage::set_snapshotvalid(bool value) {
  _internal_set_snapshotvalid(value);
  // @@protoc_insertion_point(field_set:RaftMes.SnapshotMessage.SnapshotValid)
}

// string Snapshot = 2;
inline void SnapshotMessage::clear_snapshot() {
  snapshot_.ClearToEmpty();
}
inline const std::string& SnapshotMessage::snapshot() const {
  // @@protoc_insertion_point(field_get:RaftMes.SnapshotMessage.Snapshot)
  return _internal_snapshot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnapshotMessage::set_snapshot(ArgT0&& arg0, ArgT... args) {
 
 snapshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftMes.SnapshotMessage.Snapshot)
}
inline std::string* SnapshotMessage::mutable_snapshot() {
  std::string* _s = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:RaftMes.SnapshotMessage.Snapshot)
  return _s;
}
inline const std::string& SnapshotMessage::_internal_snapshot() const {
  return snapshot_.Get();
}
inline void SnapshotMessage::_internal_set_snapshot(const std::string& value) {
  
  snapshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SnapshotMessage::_internal_mutable_snapshot() {
  
  return snapshot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SnapshotMessage::release_snapshot() {
  // @@protoc_insertion_point(field_release:RaftMes.SnapshotMessage.Snapshot)
  return snapshot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SnapshotMessage::set_allocated_snapshot(std::string* snapshot) {
  if (snapshot != nullptr) {
    
  } else {
    
  }
  snapshot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (snapshot_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    snapshot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RaftMes.SnapshotMessage.Snapshot)
}

// uint64 SnapshotTerm = 3;
inline void SnapshotMessage::clear_snapshotterm() {
  snapshotterm_ = uint64_t{0u};
}
inline uint64_t SnapshotMessage::_internal_snapshotterm() const {
  return snapshotterm_;
}
inline uint64_t SnapshotMessage::snapshotterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.SnapshotMessage.SnapshotTerm)
  return _internal_snapshotterm();
}
inline void SnapshotMessage::_internal_set_snapshotterm(uint64_t value) {
  
  snapshotterm_ = value;
}
inline void SnapshotMessage::set_snapshotterm(uint64_t value) {
  _internal_set_snapshotterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.SnapshotMessage.SnapshotTerm)
}

// uint64 SnapshotIndex = 4;
inline void SnapshotMessage::clear_snapshotindex() {
  snapshotindex_ = uint64_t{0u};
}
inline uint64_t SnapshotMessage::_internal_snapshotindex() const {
  return snapshotindex_;
}
inline uint64_t SnapshotMessage::snapshotindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.SnapshotMessage.SnapshotIndex)
  return _internal_snapshotindex();
}
inline void SnapshotMessage::_internal_set_snapshotindex(uint64_t value) {
  
  snapshotindex_ = value;
}
inline void SnapshotMessage::set_snapshotindex(uint64_t value) {
  _internal_set_snapshotindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.SnapshotMessage.SnapshotIndex)
}

// -------------------------------------------------------------------

// ApplyMessage

// bool CommandVaild = 1;
inline void ApplyMessage::clear_commandvaild() {
  commandvaild_ = false;
}
inline bool ApplyMessage::_internal_commandvaild() const {
  return commandvaild_;
}
inline bool ApplyMessage::commandvaild() const {
  // @@protoc_insertion_point(field_get:RaftMes.ApplyMessage.CommandVaild)
  return _internal_commandvaild();
}
inline void ApplyMessage::_internal_set_commandvaild(bool value) {
  
  commandvaild_ = value;
}
inline void ApplyMessage::set_commandvaild(bool value) {
  _internal_set_commandvaild(value);
  // @@protoc_insertion_point(field_set:RaftMes.ApplyMessage.CommandVaild)
}

// string Command = 2;
inline void ApplyMessage::clear_command() {
  command_.ClearToEmpty();
}
inline const std::string& ApplyMessage::command() const {
  // @@protoc_insertion_point(field_get:RaftMes.ApplyMessage.Command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplyMessage::set_command(ArgT0&& arg0, ArgT... args) {
 
 command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RaftMes.ApplyMessage.Command)
}
inline std::string* ApplyMessage::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:RaftMes.ApplyMessage.Command)
  return _s;
}
inline const std::string& ApplyMessage::_internal_command() const {
  return command_.Get();
}
inline void ApplyMessage::_internal_set_command(const std::string& value) {
  
  command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ApplyMessage::_internal_mutable_command() {
  
  return command_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ApplyMessage::release_command() {
  // @@protoc_insertion_point(field_release:RaftMes.ApplyMessage.Command)
  return command_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ApplyMessage::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (command_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RaftMes.ApplyMessage.Command)
}

// uint64 CommandIndex = 3;
inline void ApplyMessage::clear_commandindex() {
  commandindex_ = uint64_t{0u};
}
inline uint64_t ApplyMessage::_internal_commandindex() const {
  return commandindex_;
}
inline uint64_t ApplyMessage::commandindex() const {
  // @@protoc_insertion_point(field_get:RaftMes.ApplyMessage.CommandIndex)
  return _internal_commandindex();
}
inline void ApplyMessage::_internal_set_commandindex(uint64_t value) {
  
  commandindex_ = value;
}
inline void ApplyMessage::set_commandindex(uint64_t value) {
  _internal_set_commandindex(value);
  // @@protoc_insertion_point(field_set:RaftMes.ApplyMessage.CommandIndex)
}

// uint64 CommandTerm = 4;
inline void ApplyMessage::clear_commandterm() {
  commandterm_ = uint64_t{0u};
}
inline uint64_t ApplyMessage::_internal_commandterm() const {
  return commandterm_;
}
inline uint64_t ApplyMessage::commandterm() const {
  // @@protoc_insertion_point(field_get:RaftMes.ApplyMessage.CommandTerm)
  return _internal_commandterm();
}
inline void ApplyMessage::_internal_set_commandterm(uint64_t value) {
  
  commandterm_ = value;
}
inline void ApplyMessage::set_commandterm(uint64_t value) {
  _internal_set_commandterm(value);
  // @@protoc_insertion_point(field_set:RaftMes.ApplyMessage.CommandTerm)
}

// optional .RaftMes.SnapshotMessage snapshot = 5;
inline bool ApplyMessage::_internal_has_snapshot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || snapshot_ != nullptr);
  return value;
}
inline bool ApplyMessage::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void ApplyMessage::clear_snapshot() {
  if (snapshot_ != nullptr) snapshot_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::RaftMes::SnapshotMessage& ApplyMessage::_internal_snapshot() const {
  const ::RaftMes::SnapshotMessage* p = snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::RaftMes::SnapshotMessage&>(
      ::RaftMes::_SnapshotMessage_default_instance_);
}
inline const ::RaftMes::SnapshotMessage& ApplyMessage::snapshot() const {
  // @@protoc_insertion_point(field_get:RaftMes.ApplyMessage.snapshot)
  return _internal_snapshot();
}
inline void ApplyMessage::unsafe_arena_set_allocated_snapshot(
    ::RaftMes::SnapshotMessage* snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(snapshot_);
  }
  snapshot_ = snapshot;
  if (snapshot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RaftMes.ApplyMessage.snapshot)
}
inline ::RaftMes::SnapshotMessage* ApplyMessage::release_snapshot() {
  _has_bits_[0] &= ~0x00000001u;
  ::RaftMes::SnapshotMessage* temp = snapshot_;
  snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RaftMes::SnapshotMessage* ApplyMessage::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:RaftMes.ApplyMessage.snapshot)
  _has_bits_[0] &= ~0x00000001u;
  ::RaftMes::SnapshotMessage* temp = snapshot_;
  snapshot_ = nullptr;
  return temp;
}
inline ::RaftMes::SnapshotMessage* ApplyMessage::_internal_mutable_snapshot() {
  _has_bits_[0] |= 0x00000001u;
  if (snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::RaftMes::SnapshotMessage>(GetArenaForAllocation());
    snapshot_ = p;
  }
  return snapshot_;
}
inline ::RaftMes::SnapshotMessage* ApplyMessage::mutable_snapshot() {
  ::RaftMes::SnapshotMessage* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:RaftMes.ApplyMessage.snapshot)
  return _msg;
}
inline void ApplyMessage::set_allocated_snapshot(::RaftMes::SnapshotMessage* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RaftMes::SnapshotMessage>::GetOwningArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:RaftMes.ApplyMessage.snapshot)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RaftMes

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_raft_2eproto
